* Preface
- First off, I would like to thank all these people and groups for having created great content for clojure workshops.
  - Aditya Athale
  - Kyle Kingsbury (aphyr)
  - ClojureBridge Berlin and London

- We have taken most of our ideas for this workshop from the content these folks have created.

- This workshop is aimed specifically at women. Why? In the past 7
  years of my engineering career I have seen the disparity in gender
  ratio at all the companies I have worked with. In some teams, I was
  the only female developer. In some teams, I was the only female. I
  have never had a female mentor before. But, I have also seen
  companies change, grow, become more aware of this lacking, and
  find ways to fix it. This is a small attempt towards that. Getting more
  females to learn programming, learn Clojure and do awesome things
  that comes with ability to command a computer.

- To quote aphyr - "So before we begin, I want to reinforce that you
  can program, that you can do math, that you can design car
  suspensions and fire suppression systems and spacecraft control
  software and distributed databases, regardless of what your
  classmates and media and even fellow engineers think."

* Structure
** What is programming
- Programming is the process of creating a set of instructions that tell a computer how to perform a task. Programming can be done using a variety of computer "languages".
- There are many such languages to choose from. Some of the other languages you might have heard of (or will hear of!) are C, JavaScript, Python, and Java.
- And Clojure, of course.
- Every program has two readers: the computer, and the human. Our job, as programmers, is to communicate clearly to both.


** What is Clojure
- Clojure is a modern dialect of a very old family of computer languages, called Lisp.
- It is also closely related to Java as it runs on the Java platform and fully supports calling Java code from CLojure (you can ignore this for now).
- what can you do in Clojure?
- you can create web things, mobile things, sketch things

** Why Clojure
- Clojure is *simple*. That’s not to say it’s not powerful; it is. The
  number of concepts you have to know to program in Clojure is very
  small, however, and easy to grasp. Clojure grows with you as you
  learn it, and you can be very productive with a small subset of the
  language.
- Clojure is *all-purpose*. Some languages have a specific
  focus. JavaScript, for example, was traditionally used only in web
  pages (although that’s changed somewhat). Objective-C is used mainly
  for iPhone apps. We’re going to make a drawing application today,
  but you can use Clojure for any sort of application easily.
- Clojure is *fun*. That’s a matter of opinion, of course, but we think
  it holds true. I hope that during this course you experience the joy
  of seeing a Clojure program come together and do something powerful
  and surprising.


** Understanding the REPL
- REPL stands for Read, Evaluate, Print Loop
- Many programming languages, including Clojure, have a way to execute code interactively so you get instant feedback.
- In other words, the code is read, then it is evaluated, then the result is printed, and you begin again–thus, a loop.
- let's start a REPL. and we can type and evaluate things as we go on learning them.
- as a first thing, type `nil` in your REPL, and see what it returns.
  - `nil` is the most basic value in Clojure, it represents emptiness, nothing-doing, not-a-thing.

** Syntax, or anatomy of s-expressions
- s-expressions or symbolic expressions
- `(prn "Hello World")` ;; evauluate this
- all Clojure code is composed of these s-expressions and all these s-expressions evaluate to a value
- Notice the parentheses. Parentheses enclose instructions to the
  computer in Clojure. A left parenthesis is the start of the
  instruction, and a matching right parenthesis is the end of
  enclosing instruction. Normally, Clojure code has a lot of nested
  parentheses, or in other words, nested enclosing instructions.
- The Clojure "Reader" (the 'R' part of the R.E.P.L) expects each open bracket to be accompanied by a corresponding closing bracket. i.e. all parentheses must be "balanced".
- Clojure uses whitespace to separate operands, and it treats commas as whitespace.

- All Clojure code is written in a uniform structure. Clojure recognizes two kinds of structures:
1. Literal representations of data structures (like numbers, strings, maps, and vectors)
2. expressions

- in any expression, you have nouns and verbs
- nouns are things in the world
  - these are the values that we pass to an expression, or what an expression evaluates to
  - the values can be of different types
  - most languages have some basic data types
  - number, string (text), boolean (true/false)
  - nil, true, 0, and "hi there!" are all different types of values

- functions are the verbs in prgramming
  - given some values (arguments/parameters), they return a value

** Simple data types - string, bool and numbers
- we have already covered what values/things are
- 1, 2.5, nil, true, "hello"; these are all values
- but as you can probably already tell, they are all different values
- in other words - different types of values
- types relate to each other. for example in math, both 1 and 2.5 are
  numbers; but 1 is a natural number while 2.5 is real number
- every language has a type system; a particular way of organizing
  nouns into groups, figuring out which verbs make sense on which
  types, and relating types to one another
- Clojure's type system is:
  - *strong* in that operations on improper types are simply not allowed
  - *dynamic* because they are enforced when the program is run,
    instead of when the program is first read by the computer (in
    other words, at runtime vs compile time)
List of basic types:
1) nil
2) Numbers: Integer, Ratio, Float - 1, 3/4, 2.5
3) Strings: text like "hey", "cats are so nice", "ありがとう"
4) Characters: \a, \b, \c

- infix vs. prefix notation [TODO]

** Special data types - symbols and keywords
- keywords
  - clojure has a special type called keyword
  - eg - :foo, :bar
  - special because they are symbolic identifiers that evaluate to themselves

- symbols
  - identifiers that are used to refer to something else
  - like there is a function called `inc` which is used to increment a number
  - unlike 0, "hi", inc is a symbol
  - when Clojure evaluates a symbol, it looks up that symbol’s meaning
  - type inc in your REPL, you will get the meaning of what inc represents
  - we can also refer to symbol itself without evaluating it - `'inc`
  - the single quote ' escapes a sentence
  - a quote says “Rather than evaluating this expression’s text, simply return the text itself, unchanged.”
  - try: '123, '"foo", 'true
  - quoting a value will return just the sa,e value back
  - quoting a symbol will return that symbol unevaluated

- def
  - we use def to bind a symbol to its value
  - `(def chosen-one "Harry Potter")`
  - here, we have bound the symbol 'chosen-one to the string "Harry Potter"
  - If we had to type the same values over and over, it would be very
    hard to write a program. So, we bind them to symbols so we
    can refer to them in a way we can remember.

** Functions I (built-in fns)
** Sequence / Collection types and associated functions
- lists are what they mean: a collection of things
- `[1 2 3]`, `[:a :b :c]`, `["a", "b", "c"]`
- these are all collections of different types
- but clojure doesn't put any restrictions on the type of data you can put in a collection
- `[1 :a "a" 2 :b]` is also a valid collection
- there are different types of collections:
1. lists - `(1 2 3)
2. vectors - [1 2 3]
3. hash maps - {:a 1 :b 2 :c 3}
4. sets - #{1 2 3}
- uniform way to use all of these collections together
- some built in fns which make working with collections easy
- conj - adds an element to the collection
- map - goes over the collection and applies a function over all elements in the collection returning a new collection

** Functions II (introduce defn, fn et al)
** Context and bindings (let)
** Control flow and logic (if, when, do)
- control flow is the programming term for deciding how to react to a given circumstance. We make decisions like this all the time

- if your charging station is dead, take a cab
- if your wet and dry waste is not segregated, pay a fine to bbmp

- if something is true or false or a bunch of things are true or false, react

- most of what we do today in software this kind of decision making
  - the user input valid? if yes, save her data, otherwise throw an error

- hence, changing the order of evaluation in a language is called control flow, and lets programs make decisions based on varying circumstances

*** if

#+begin_src clojure
(if (= 2 2) "yes" "no")
#+end_src

#+begin_src clojure
(if (< (+ y 40) 150)
  (+ y 40)
  -150)
#+end_src

#+begin_src clojure
(if "conditional-expression"
  "expression-to-evaluate-when-true"
  "expression-to-evaluate-when-false")
#+end_src

- truthiness:
  - when testing the truth of an expression, Clojure considers the values nil and false to be false and everything else to be true. Here are some examples

#+begin_src clojure
(if "anything other than nil or false is considered true"
  "A string is considered true"
  "A string is not considered true")
#+end_src

#+begin_src clojure
(if nil
  "nil is considered true"
  "nil is not considered true")
#+end_src

#+begin_src clojure
(if (get {:a 1} :b)
  "expressions which evaluate to nil are considered true"
  "expressions which evaluate to nil are not considered true")
#+end_src

*** boolean logic

- if statements are not limited to testing only one thing, you can test multiple conditions using boolean logic. Boolean logic refers to combining and changing the results of predicates using and, or, and not.

#+begin_src clojure
(or 1 2)
(or false 2)
(or true false)


(and 1 2)
(and false false)
(and false 2)
(and 2 false)

(not false)
#+end_src

*** leap year?

**** begin
#+begin_src clojure
(defn leap-year? [year]
  "Every four years, except years divisible by 100, but yes for years divisible by 400.")
#+end_src

**** first conditional
#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (= 0 (mod year 4)))
#+end_src

**** second conditional
#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (and (= 0 (mod year 4)
       (= 0 (mod year 400)))))
#+end_src

**** third conditional

#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (and (= 0 (mod year 4))
       (or (= 0 (mod year 400))
           (not (= 0 (mod year 100))))))
#+end_src

*** when

- if you’ve never seen this concept in programming before, remember that it follows the common sense way you look at things normally.
  - Is this and that true? Only if both are true.
  - Is this or that true? Yes, if either – or both! – are.
  - Is this not true? Yes, if it’s false.

- when you only want to take one branch of an if, you can use when:

#+begin_src clojure
(when false
  (prn :hi)
  (prn :there))
#+end_src


#+begin_src clojure
(when true
  (prn :hi)
  (prn :there))
#+end_src

- because there is only one path to take, when takes any number of expressions, and evaluates them only when the predicate is truthy. If the predicate evaluates to nil or false, when does not evaluate its body, and returns nil.

- exercise: Using the control flow constructs we’ve learned, write a schedule function which, given an hour of the day, returns what you’ll be doing at that time. (schedule 18), for us, returns :dinner

** Composition of functions

** First Program
- https://github.com/ClojureBridge/drawing/blob/master/curriculum/first-program.md
