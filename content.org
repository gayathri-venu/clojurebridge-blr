* Preface
- First off, I would like to thank all these people and groups for having created great content for clojure workshops.
  - Aditya Athale
  - Kyle Kingsbury (aphyr)
  - ClojureBridge Berlin and London

- We have taken most of our ideas for this workshop from the content these folks have created.

- This workshop is aimed specifically at women. Why? In the past 7
  years of my engineering career I have seen the disparity in gender
  ratio at all the companies I have worked with. In some teams, I was
  the only female developer. In some teams, I was the only female. I
  have never had a female mentor before. But, I have also seen
  companies change, grow, become more aware of this lacking, and
  find ways to fix it. This is a small attempt towards that. Getting more
  females to learn programming, learn Clojure and do awesome things
  that comes with ability to command a computer.

- To quote aphyr - "So before we begin, I want to reinforce that you
  can program, that you can do math, that you can design car
  suspensions and fire suppression systems and spacecraft control
  software and distributed databases, regardless of what your
  classmates and media and even fellow engineers think."

* Structure
** What is programming
- Programming is the process of creating a set of instructions that tell a computer how to perform a task. Programming can be done using a variety of computer "languages".
- There are many such languages to choose from. Some of the other languages you might have heard of (or will hear of!) are C, JavaScript, Python, and Java.
- And Clojure, of course.
- Every program has two readers: the computer, and the human. Our job, as programmers, is to communicate clearly to both.


** What is Clojure
- Clojure is a modern dialect of a very old family of computer languages, called Lisp.
- It is also closely related to Java as it runs on the Java platform and fully supports calling Java code from Clojure (you can ignore this for now).
- What can you do in Clojure?
- You can create web things, mobile things, sketch things

** Why Clojure
- Clojure is *simple*. That’s not to say it’s not powerful; it is. The
  number of concepts you have to know to program in Clojure is very
  small, however, and easy to grasp. Clojure grows with you as you
  learn it, and you can be very productive with a small subset of the
  language.
- Clojure is *all-purpose*. Some languages have a specific
  focus. JavaScript, for example, was traditionally used only in web
  pages (although that’s changed somewhat). Objective-C is used mainly
  for iPhone apps. We’re going to make a drawing application today,
  but you can use Clojure for any sort of application easily.
- Clojure is *fun*. That’s a matter of opinion, of course, but we think
  it holds true. I hope that during this course you experience the joy
  of seeing a Clojure program come together and do something powerful
  and surprising.


** Understanding the REPL
- REPL stands for Read, Evaluate, Print Loop
- Many programming languages, including Clojure, have a way to execute code interactively so you get instant feedback.
- In other words, the code is read, then it is evaluated, then the result is printed, and you begin again–thus, a loop.
- Let's start a REPL. and we can type and evaluate things as we go on learning them.
- As a first thing, type `nil` in your REPL, and see what it returns.
  - `nil` is the most basic value in Clojure, it represents emptiness, nothing-doing, not-a-thing.

** Syntax, or anatomy of s-expressions
- s-expressions or symbolic expressions
#+BEGIN_SRC clojure
(prn "Hello World") ;; evauluate this
#+END_SRC
- All Clojure code is composed of these s-expressions and all these s-expressions evaluate to a value
- Notice the parentheses. Parentheses enclose instructions to the
  computer in Clojure. A left parenthesis is the start of the
  instruction, and a matching right parenthesis is the end of
  enclosing instruction. Normally, Clojure code has a lot of nested
  parentheses, or in other words, nested enclosed instructions.
- The Clojure "Reader" (the 'R' part of the R.E.P.L) expects each open bracket to be accompanied by a corresponding closing bracket. i.e. all parentheses must be "balanced".
- Clojure uses whitespace to separate operands, and it treats commas as whitespace.
- All Clojure code is written in a uniform structure. Clojure recognizes two kinds of structures:
1. Literal representations of data structures (like numbers, strings, maps, and vectors)
2. Expressions - in any expression, you have nouns and verbs

*** nouns
- Nouns are things in the world
- These are the values that we pass to an expression, or what an expression evaluates to
- The values can be of different types
- Most languages have some basic data types
- number, string (text), boolean (true/false)
- nil, true, 0, and "hi there!" are all different types of values

*** verbs
- Functions are the verbs in programming
- Given some values (arguments/parameters), they return a value

** Simple data types - string, bool and numbers
- We have already covered what values/things are
- 1, 2.5, nil, true, "hello"; these are all values
- But as you can probably already tell, they are all different values
- In other words - different types of values
- Types relate to each other. for example in math, both 1 and 2.5 are
  numbers; but 1 is a natural number while 2.5 is real number
- Every language has a type system; a particular way of organizing
  nouns into groups, figuring out which verbs make sense on which
  types, and relating types to one another
- Clojure's type system is:
  - *strong* in that operations on improper types are simply not allowed
  - *dynamic* because they are enforced when the program is run,
    instead of when the program is first read by the computer (in
    other words, at runtime vs compile time)
List of basic types:
1) nil
2) Numbers: Integer, Ratio, Float - 1, 3/4, 2.5
3) Strings: text like "hey", "cats are so nice", "ありがとう"
4) Characters: \a, \b, \c


*** Infix vs. prefix notation  
  
  Infix and prefix notation refer to two different ways of representing an expression
  - Infix notation  
    
    Infix notation places the operator *in* between the operands
    #+BEGIN_SRC
    1 + 2 + 3 * 4
    1 + 2 + 12
    1 + 14
    15
    #+END_SRC
    Infix notation should be familiar to most people.
    In infix notation, the order of operations is not always obvious, deciding which operation should happen 
    first requires first deciding on an operator precedence hierarchy. In this case - BODMAS or PEMDAS or something similar.

  - Prefix notation 

    Prefix notation places the operator before or *pre* the operands
    #+BEGIN_SRC
    + 1 + 2 * 3 4
    + 1 + 2 12
    + 1 14
    15
    #+END_SRC
    Prefix notation sidesteps the need to have an operator precedence hierarchy. 
    Since the operands always follow the operator, there is no ambiguity around
    which operator applies to a given operand.
  
  Clojure uses the prefix notation, and pairs it with the s-expressions and parantheses we've already seen to give us a concise and unambiguous notation.
  #+BEGIN_SRC clojure
  (+ 1 2 (* 3 4))
  (+ 1 2 12)
  15
  #+END_SRC 

** Special data types - symbols and keywords
*** keywords
- Clojure has a special type called keyword
- eg - :foo, :bar
- Special because they are symbolic identifiers that evaluate to themselves

*** symbols
- Identifiers that are used to refer to something else
- For example, there is a function called `inc` which is used to increment a number
- Unlike 0, "hi", inc is a symbol
- When Clojure evaluates a symbol, it looks up that symbol’s meaning
- Type inc in your REPL, you will get the meaning of what inc represents
- We can also refer to symbol itself without evaluating it - `'inc`
- The single quote ' escapes a sentence
- A quote says “Rather than evaluating this expression’s text, simply return the text itself, unchanged.”
- Try: '123, '"foo", 'true
- Quoting a value will return just the sa,e value back
- Quoting a symbol will return that symbol unevaluated

*** def
- We use def to bind a symbol to its value
#+BEGIN_SRC clojure
(def chosen-one "Harry Potter")
#+END_SRC
- Here, we have bound the symbol 'chosen-one to the string "Harry Potter"
- If we had to type the same values over and over, it would be very
  hard to write a program. So, we bind them to symbols so we
  can refer to them in a way we can remember.

** Functions
- Functions we have seen so far
#+BEGIN_SRC clojure
(+ 1 2)
(str "this is a function " "that combines two strings")
(prn "this function prints whatever you give it")
(inc 42)
#+END_SRC
- A function is an independent, discrete piece of code that takes in some values (called arguments) and returns a value
- Each function takes in zero or more number of arguments and returns one value

*** calling a function
- By now you’ve seen many examples of function calls
#+BEGIN_SRC clojure
(+ 1 2 3 4)
#+END_SRC
- All Clojure operations have the same syntax: opening parenthesis, operator, operands, closing parenthesis
- Function call is just another term for an operation where the operator is a function or a function expression (an expression that returns a function)
#+BEGIN_SRC clojure
(1 2 3 4)
("test" 1 2 3)
#+END_SRC
- The above examples are not valid function calls as the operator is not a function
- Evaulate them to see what result you get
- You might see that exception a lot while coding in Clojure
- <x> cannot be cast to clojure.lang.IFn just means that you’re trying to use something as a function when it’s not

*** write your own function

**** defn
#+BEGIN_SRC
(defn same [x] x)
#+END_SRC
- Function definitions are composed of five main parts:
1. defn
2. Function name
3. A docstring describing the function (optional)
4. Parameters listed in brackets
5. Function body

- In the above example, you have defined a fn that takes an argument and returns it back
- Try it out
#+BEGIN_SRC
(same 42)
(same "am I the same")
(same :foo)
#+END_SRC
- Exercise: write a function to add 10 to a number

**** fn
- This is another way of defining a fn
#+BEGIN_SRC
(fn same [x] x)
#+END_SRC

- You can also write functions without any names
#+BEGIN_SRC
(fn same [x] x)
#+END_SRC

- The function body can contain forms of any kind
- Clojure automatically returns the last form evaluated
#+BEGIN_SRC
(defn return-something []
  1
  (+ 1 2)
  2
  "foo")
#+END_SRC

- All functions are created equal, there are no "special" functions. Even the core fns are the same as the ones you create.

** Sequence / Collection types and associated functions
- lists are what they mean: a collection of things
- `[1 2 3]`, `[:a :b :c]`, `["a", "b", "c"]`
- These are all collections of different types
- But clojure doesn't put any restrictions on the type of data you can put in a collection
- `[1 :a "a" 2 :b]` is also a valid collection
- There are different types of collections:
1. lists - `(1 2 3)
2. vectors - [1 2 3]
3. hash maps - {:a 1 :b 2 :c 3}
4. sets - #{1 2 3}

Clojure provides:
- A uniform way to use all of these collections together
- Some built in fns which make working with collections easy
- conj - adds an element to the collection
- map - goes over the collection and applies a function to each of the elements in the collection. Returns a new collection with the results.

** Context and bindings (let)
- let is a Clojure special form, a fundamental building block of the language
- When you are creating functions, you may want to assign names to values in order to reuse those values or make your code more readable.
- Inside of a function, however, you should not use def, like you would outside of a function.
- Instead, you should use a special form called let.
- Like def, let creates a binding
#+BEGIN_SRC clojure
(let [mangoes 3
      oranges 5]
  (+ mangoes oranges))
#+END_SRC

#+BEGIN_SRC clojure
(def x 32)
(let [x 42]
  (prn x))
#+END_SRC
- let lets you evaulate expressions in the context of its bindings
- In other languages, it is called a local variable assignment
- In Clojure, it has the different name: lexical binding
- Clojure’s lexically bound variables are available to use in a limited code block (scope)
- Write as many bindings (key-value pairs) as we want within the square brackets

#+BEGIN_SRC clojure
(let [x 1
      y 1
      z (+ x y)
      z (* 2 z)]
  (println z)
  x)
#+END_SRC
- let also returns the last expression in

** Control flow and logic (if, when, do)
- Control flow is the programming term for deciding how to react to a given circumstance. We make decisions like this all the time

- If your charging station is dead, take a cab
- If your wet and dry waste is not segregated, pay a fine to bbmp

- If something is true or false or a bunch of things are true or false, react

- Most of what we do today in software is this kind of decision making
  - Is the user input valid? if yes, save her data, otherwise throw an error

- Hence, changing the order of evaluation in a language is called control flow, and lets programs make decisions based on varying circumstances

*** if

#+begin_src clojure
(if (= 2 2) "yes" "no")
#+end_src

#+begin_src clojure
(if (< (+ y 40) 150)
  (+ y 40)
  -150)
#+end_src

#+begin_src clojure
(if "conditional-expression"
  "expression-to-evaluate-when-true"
  "expression-to-evaluate-when-false")
#+end_src

- Truthiness:
  - When testing the truth of an expression, Clojure considers the values nil and false to be false and everything else to be true. Here are some examples

#+begin_src clojure
(if "anything other than nil or false is considered true"
  "A string is considered true"
  "A string is not considered true")
#+end_src

#+begin_src clojure
(if nil
  "nil is considered true"
  "nil is not considered true")
#+end_src

#+begin_src clojure
(if (get {:a 1} :b)
  "expressions which evaluate to nil are considered true"
  "expressions which evaluate to nil are not considered true")
#+end_src

*** boolean logic

- if statements are not limited to testing only one thing, you can test multiple conditions using boolean logic. Boolean logic refers to combining and changing the results of predicates using and, or, and not.

#+begin_src clojure
(or 1 2)
(or false 2)
(or true false)


(and 1 2)
(and false false)
(and false 2)
(and 2 false)

(not false)
#+end_src

*** leap year?

**** begin
#+begin_src clojure
(defn leap-year? [year]
  "Every four years, except years divisible by 100, but yes for years divisible by 400.")
#+end_src

**** first conditional
#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (= 0 (mod year 4)))
#+end_src

**** second conditional
#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (and (= 0 (mod year 4)
       (= 0 (mod year 400)))))
#+end_src

**** third conditional

#+begin_src clojure
(defn leap-year?
  "Every four years, except years divisible by 100, but yes for years divisible by 400."
  [year]
  (and (= 0 (mod year 4))
       (or (= 0 (mod year 400))
           (not (= 0 (mod year 100))))))
#+end_src

*** when

- If you’ve never seen this concept in programming before, remember that it follows the common sense way you look at things normally.
  - Is this and that true? Only if both are true.
  - Is this or that true? Yes, if either – or both! – are.
  - Is this not true? Yes, if it’s false.

- When you only want to take one branch of an if, you can use when:

#+begin_src clojure
(when false
  (prn :hi)
  (prn :there))
#+end_src


#+begin_src clojure
(when true
  (prn :hi)
  (prn :there))
#+end_src

- Because there is only one path to take, when takes any number of expressions, and evaluates them only when the predicate is truthy. If the predicate evaluates to nil or false, when does not evaluate its body, and returns nil.


*** exercise

Using the control flow constructs we’ve learned, write a schedule function which, given an hour of the day, returns what you’ll be doing at that time.

#+begin_src clojure
(schedule 18) ;; for us, returns :dinner
#+end_src

** Composition of functions

** First Program
- https://github.com/ClojureBridge/drawing/blob/master/curriculum/first-program.md
